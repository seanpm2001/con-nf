

<!DOCTYPE html>
<html>
<head>
  <title>Dependency graph</title>
  <meta name="generator" content="plasTeX" />
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles/theme-white.css" />
  <link rel="stylesheet" href="styles/dep_graph.css" />
  
  <script type="text/x-mathjax-config">
  
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  
  </script>

  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">  </script>


</head>

<body>
<header>
  <a class="toc" href="index.html">Home</a>
  <h1 id="doc_title">Dependencies</h1>
</header>
<div class="wrapper">
<div class="content">
  <div id="Legend">
    <span id="legend_title" class="title">Legend
    <div class="btn">
       <div class="bar"></div>
       <div class="bar"></div>
       <div class="bar"></div>
    </div></span> 
    <dl class="legend">
      <dt>Boxes</dt><dd>definitions</dd>
      <dt>Ellipses</dt><dd>theorems and lemmas</dd>
      <dt>Blue border</dt><dd>the <em>statement</em> of this result is ready to be formalized; all prerequisites are done</dd>
      <dt>Blue background</dt><dd>the <em>proof</em> of this result is ready to be formalized; all prerequisites are done</dd>
      <dt>Green border</dt><dd>the <em>statement</em> of this result is formalized</dd>
      <dt>Green background</dt><dd>the <em>proof</em> of this result is formalized</dd>
    </dl>
  </div>
    <div id="graph"></div>
<div id="statements">

    
    <div class="dep-modal-container" id="cor:count-coding-functions_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="cor:count-coding-functions" style="display: none">
    <div class="thm_thmheading">
      <span class="corollary_thmcaption">
      Corollary
      </span>
      <span class="corollary_thmlabel">3.38</span></div>
    <div class="thm_thmcontent"><p>  There are \({\lt}\mu \)-many coding functions. </p>
</div>

    <a class="latex_link" href="sect0001.html#cor:count-coding-functions">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="cor:count-strong-supports_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="cor:count-strong-supports" style="display: none">
    <div class="thm_thmheading">
      <span class="corollary_thmcaption">
      Corollary
      </span>
      <span class="corollary_thmlabel">3.33</span></div>
    <div class="thm_thmcontent"><p>  There are \({\lt}\mu \)-many orbits of strong supports, under the group action of allowable permutations. </p>
</div>

    <a class="latex_link" href="sect0001.html#cor:count-strong-supports">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="cor:count-tangles_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="cor:count-tangles" style="display: none">
    <div class="thm_thmheading">
      <span class="corollary_thmcaption">
      Corollary
      </span>
      <span class="corollary_thmlabel">3.39</span></div>
    <div class="thm_thmcontent"><p>  There are \(\mu \)-many \(\alpha \)-tangles. </p>
</div>

    <a class="latex_link" href="sect0001.html#cor:count-tangles">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:a-map_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:a-map" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.5</span></div>
    <div class="thm_thmcontent"><p>   Let \(\gamma \) be a type index (not necessarily proper) below \(\alpha \). </p>
<p>For any code \((\alpha ,\gamma ,G)\), with \(\delta \) a proper type index below \(\alpha \) and distinct from \(\gamma \), we define \(A_\delta (\alpha ,\gamma ,G)\) as </p>
<div class="displaymath" id="a0000000025">
  \[ (\alpha ,\delta ,\{  j_\delta (N) \mid N \in \mathcal{NL},\,  N \sim f_{\gamma ,\delta }(g),\,  g \in G \} ) \]
</div>
<p> if the maps \(f_{\gamma ,\delta }\) are considered as valued in litters, or </p>
<div class="displaymath" id="a0000000026">
  \[ (\alpha ,\delta ,\{  j_\delta (N) \mid N \in f_{\gamma ,\delta }(g),\,  g \in G \} ) \]
</div>
<p> if they are taken as valued directly in local cardinals. </p>
<p>We say that a code \(c\) <em>leads to</em> a code \(d\) if \(d\) is the image of \(c\) under some A-map. We denote this \(c \rightsquigarrow d\). </p>
<p>(Here \(j_\delta (N)\) is the “typed near-litters” map for level \(\delta \), assumed in the tangle data.) </p>
<p>[For the formalisation, each individual \(A_\delta \) is probably best represented as a function \(\mathcal{P}(\tau _\gamma ) \to \mathcal{P}(\tau _\delta )\), rather than on “codes of the form \((\alpha ,\gamma ,G)\)…”. Also it could — and perhaps should, for flexibility later — have parameters just “\(\gamma \), \(\delta \), and their tangle data”, rather than “\(\alpha \), tangle data everywhere below \(\alpha \), and \(\gamma ,\delta {\lt} \alpha \)”.] </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:a-map">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/A_map.lean#L51">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:allowable-partial-perm_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:allowable-partial-perm" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.14</span></div>
    <div class="thm_thmcontent"><p>   Assume a freedom of action context at a proper type index \(\alpha \). </p>
<p>An <em>allowable partial permutation</em> is a set \(\sigma \) of binary \(\alpha \)-conditions satisfying the following properties: </p>
<ol class="enumerate">
  <li><p>It is one-to-one. </p>
</li>
  <li><p>(Flexible litters:) Either \(\mathrm{dom}\sigma \) and \(\mathrm{rge}\sigma \) both include all flexible litters, or else they both include <em>co-\(\mu \)-many</em>, i.e. there are at least \(\mu \)-many flexible litters not in \(\mathrm{dom}\sigma \), and dually for \(\mathrm{rge}\sigma \). </p>
</li>
  <li><p>(Atoms:) For each litter \((L,A)\) not in \(\mathrm{dom}\sigma \), then \(\mathrm{dom}\sigma \) contains \({\lt}\kappa \)-many atoms \((x,A)\) with \(x \in L\); and dually for \(\mathrm{rge}(\sigma )\). On the other hand, for each litter \((L,A) \in \mathrm{dom}\sigma \) (say \(\sigma _A(L)\) is the unique near-litter such that \((L,\sigma _A(L),A) \in \sigma \)), then either \(\mathrm{dom}\sigma \) contains \({\lt}\kappa \)-many atoms of \((L,A)\) and \(\mathrm{rge}\sigma \) contains \({\lt}\kappa \)-many atoms of \((M,A)\), or else \(\mathrm{dom}\sigma \) contains all atoms of \((L,A)\) and their setwise image \(\sigma _A''(L)\) is precisely \(\sigma _A(L)\); and dually for each litter \((L,A) \in \mathrm{rge}\sigma \). </p>
</li>
  <li><p>(Near-litters.) For each near-litter \((N,A) \in \mathrm{dom}\sigma \), its litter \((N^\circ ,A)\) and all atoms \((x,A)\) from the symmetric difference \(N \mathrel {\triangle }N^\circ \) are also in \(A\), and \(\sigma _A(N) = \sigma _A(N^\circ ) \mathrel {\triangle }\sigma _A''(N \mathrel {\triangle }N^\circ )\); and dually for each near-litter in \(\mathrm{rge}\sigma \). </p>
</li>
  <li><p>(Non-flexible litters.) Whenever \(\sigma \) contains some triple \((f^A_{\gamma ,\delta }(x),N,(-1;\delta ;A))\) (where \(\gamma ,\delta {\lt} \beta \dashrightarrow ^A \alpha \), \(\delta \) is proper, and \(x \in \tau _{\gamma ;A}\)), then \((\mathrm{dom}\sigma )_{\gamma ;A}\) supports \(x\), and every allowable permutation \(\rho \in \mathrm{All}_A\) extending \(\sigma _A\) has \(N = f^A_{\gamma ,\delta }(\rho _\gamma x)\). Dually, whenever \(\sigma \) contains some \((N,f^A_{\gamma ,\delta }(x),(-1;\delta ;A))\), then \((\mathrm{rge}\sigma )_{\gamma ;A}\) supports \(x\), and any allowable \(\rho \) extending \(\sigma _A\) has \(N = f^A_{\gamma ,\delta }(\rho ^{-1}_\gamma x)\) (note the inverse in this case). </p>
</li>
</ol>
<p>We will often refer to these conditions individually, as “the allowability condition for atoms”, etc. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:allowable-partial-perm">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:allowable-partial-perm-order_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:allowable-partial-perm-order" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.17</span></div>
    <div class="thm_thmcontent"><p>   Work in a freedom of action context at a proper type index \(\alpha \). </p>
<p>Given allowable partial permutations \(\sigma , \rho \), say that \(\sigma \sqsubseteq \rho \) (“\(\sigma \) <em>carefully extends</em> \(\rho \)”) if: </p>
<ol class="enumerate">
  <li><p>\(\sigma \subseteq \rho \); </p>
</li>
  <li><p>if \(\rho \) has any new flexible litter, then it has all of them (in both domain and range); </p>
</li>
  <li><p>within each litter, if \(\mathrm{dom}\rho \) has any new atom, then it must have all atoms in that litter (and hence must also have the litter); and dually. </p>
</li>
</ol>
</div>

    <a class="latex_link" href="sect0001.html#def:allowable-partial-perm-order">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:allowable-perm_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:allowable-perm" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.17</span></div>
    <div class="thm_thmcontent"><p>   An <em>allowable permutation</em> is a semi-allowable permutation which preserves \(\equiv _\alpha \): for all \(\alpha \)-codes \(X,Y\), \(X \equiv _\alpha Y \leftrightarrow \pi (X) \equiv _\alpha \pi (Y)\). </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:allowable-perm">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/allowable.lean#L96">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:allowable-perm-atoms_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:allowable-perm-atoms" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.14</span></div>
    <div class="thm_thmcontent"><p>  An <em>allowable \((-1)\)-permutation</em> is just a structural \((-1)\)-permutation. We denote the group of these by \(\mathrm{All}_{-1} = \mathrm{Str}_{-1}\). (Later we will define \(\mathrm{Str}_\beta \) as a proper subgroup of \(\mathrm{All}_\beta \), for higher \(\beta \).) </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:allowable-perm-atoms">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:atoms-and-litters_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:atoms-and-litters" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.5</span></div>
    <div class="thm_thmcontent"><p>   Define \(\mathcal{L}\) as \( (\lambda \cup \{ -1\} ) \times \lambda \times \mu \) and \(\tau _{-1}\) as \(\mathcal{L}\times \kappa \). </p>
<p>We refer to elements of \(\tau _{-1}\) as <em>atoms</em>. </p>
<p>By construction, atoms come partitioned into \(\mathcal{L}\)-many <em>litters</em> of size \(\kappa \), </p>
<div class="displaymath" id="a0000000006">
  \[  L_{\alpha ,\beta ,\xi } := \{ ((\alpha ,\beta ,\xi ),x) \mid x \in \kappa \} . \]
</div>
<p>The litters, in turn, come partitioned into \(\lambda ^2\)-many classes of size \(\mu \): </p>
<div class="displaymath" id="a0000000007">
  \[  X_{\alpha ,\beta } := \{  (\alpha ,\beta ,\xi ) \mid \xi \in \mu \} .  \]
</div>
<p>We generally identify litters \(L_{\alpha ,\beta ,\xi }\) with their indices \((\alpha ,\beta ,\xi ) \in \mathcal{L}\); for instance a quantification over “all litters” is formally a quantification over \(\mathcal{L}\). </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:atoms-and-litters">LaTeX</a>
  <div class="tooltip">
      <span class="lean_link">Lean</span>
      <ul class="tooltip_list">
        
           <li><a href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/params.lean#L250">con_nf.atom</a></li>
        
           <li><a href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/params.lean#L191">con_nf.litter</a></li>
        
      </ul>
  </div></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:binary-condition_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:binary-condition" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.4</span></div>
    <div class="thm_thmcontent"><p>   Let \(\alpha \) be a proper type index. Recall that an <em>\(\alpha \)-condition</em> is a pair \((x,A)\), where \(A\) is a path from \(-1\) to \(\alpha \) (aka an extended type index) and \(x\) is either an atom or a near-litter; the set of these was denoted \(\mathrm{Cond}_\alpha := (\tau _{-1} + \mathcal{NL}) \times \mathrm{Path}(-1,\alpha )\). </p>
<p>A <em>binary condition</em> similarly consists of a pair of atoms or of near-litters, together with a path from \(-1\) to \(\alpha \): </p>
<div class="displaymath" id="a0000000043">
  \[  \mathrm{BiCond}_\alpha := (\tau _{-1}^2 + \mathcal{NL}^2) \times \mathrm{Path}(-1,\alpha ). \]
</div>
</div>

    <a class="latex_link" href="sect0001.html#def:binary-condition">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:code_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:code" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.2</span></div>
    <div class="thm_thmcontent"><p>   An \(\alpha \)-code is a triple \((\alpha ,\gamma ,G)\) where \(\gamma {\lt}\alpha \) and \(G \subseteq \tau _\gamma \). [The original set-theoretic implementation includes the \(\alpha \), to keep codes at different levels disjoint. In the type-theoretic implementation, the first component \(\alpha \) is unnecessary.] </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:code">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/code.lean#L12">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:code-action_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:code-action" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.16</span></div>
    <div class="thm_thmcontent"><p>   Semi-allowable permutations act on \(\alpha \)-codes. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:code-action">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/allowable.lean#L75">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:code-equiv_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:code-equiv" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.10</span></div>
    <div class="thm_thmcontent"><p>   We define an equivalence relation \(\equiv _\alpha \) on \(\alpha \)-codes inductively: </p>
<ol class="enumerate">
  <li><p>For every code \(c\), \(c \equiv _\alpha c\). </p>
</li>
  <li><p>If \((\alpha ,\gamma ,G)\) is even and \(\gamma \neq \delta \), then \((\alpha ,\gamma ,G) \equiv _\alpha A_\delta (\alpha ,\gamma ,G)\) and \(A_\delta (\alpha ,\gamma ,G) \equiv _\alpha (\alpha ,\gamma ,G)\). </p>
</li>
  <li><p>If \((\alpha ,\gamma ,G)\) is even and \(\gamma \neq \delta , \varepsilon \), then \(A_\delta (\alpha ,\gamma ,G) \equiv _\alpha A_\varepsilon (\alpha ,\gamma ,G)\). </p>
</li>
</ol>
<p>This is reflexive and symmetric by definition, and transitive by using the properties of code parity. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:code-equiv">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/code_equiv.lean#L176">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:code-parity_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:code-parity" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.8</span></div>
    <div class="thm_thmcontent"><p>   A code is <em>even</em> if it only leads to odd codes. A code is <em>odd</em> if it leads to some even code. </p>
<p>Note: This exactly says that even codes are the losing positions of the game whose states are codes and possible moves are taking the preimage under some A-map. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:code-parity">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/code_equiv.lean#L58">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:coding-function_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:coding-function" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.27</span></div>
    <div class="thm_thmcontent"><p>  For any support \(S\) and tangle \(x\), we can define a function \(\chi _{x,S}\) which sends \(T=\pi (S)\) to \(\pi (x)\) for every \(T\) in the orbit of \(S\) under the action of allowable permutations. We call such functions <em>coding functions </em>. Note that if \(\pi [S]=\pi '[S]\) then \((\pi ^{-1}\circ \pi ')[S]= S\), so \((\pi ^{-1}\circ \pi ')(x)= x\), so \(\pi (x)=\pi '(x)\), ensuring that the map \(\chi _{x,S}\) for which we gave an implicit definition is well defined. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:coding-function">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:coding-function-spec_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:coding-function-spec" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.34</span></div>
    <div class="thm_thmcontent"><p>  A <em>coding function specification</em> is …[again, see recent versions of Randall’s note] </p>
</div>

    <a class="latex_link" href="sect0001.html#def:coding-function-spec">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:coding-function-spec-realisation_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:coding-function-spec-realisation" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.36</span></div>
    <div class="thm_thmcontent"><p>  Any coding function specification can be realised as a coding function. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:coding-function-spec-realisation">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:condition-dom-rge_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:condition-dom-rge" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.9</span></div>
    <div class="thm_thmcontent"><p>   Previously, we viewed \(\alpha \)-conditions \((x,A) \in \mathrm{Cond}_\alpha \) as representing the conditions \(\pi _A(x) = x\), as used in supports (and under this view we could identify them with the binary conditions \((x,y,A)\)). In this section, we will more often view them as elements of the domain or range of a set of binary conditions. Precisely, for a set \(\sigma \) of binary conditions, we take \(\mathrm{dom}\sigma := \{  (x,A) \mid (x,y,A) \in \sigma \} \), and similarly \(\mathrm{rge}\sigma := \{  (y,A) \mid (x,y,a) \in \sigma \} \). </p>
<p>By a slight abuse of terminology, when working with sets of conditions, we will often say “litter” to mean “litter-with-path”, i.e. “condition of the form \((L,A)\)”, and similarly for near-litter” and “atom”. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:condition-dom-rge">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:condition-functoriality_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:condition-functoriality" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.5</span></div>
    <div class="thm_thmcontent"><p>   Paths act covariantly on binary conditions. Explicitly, a path \(A : \beta \to \alpha \) induces a map \((-)_A:\mathrm{BiCond}_\beta \to \mathrm{BiCond}_\alpha \), defined by \((x,B)_A := (x,B;A)\); and this preserves identities and composition. </p>
<p>Taking inverse images under these maps, paths act contravariantly on sets of binary conditions: a path \(A : \beta \to \alpha \) induces \((-)_A : \mathcal{P}(\mathrm{BiCond}_\alpha ) \to \mathcal{P}(\mathrm{BiCond}(\beta ))\), given by \(\sigma _A := \{  (x,y,B) \mid (x,y,BA) \in \sigma \} \). </p>
</div>

    <a class="latex_link" href="sect0001.html#def:condition-functoriality">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:condition-total-1-1_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:condition-total-1-1" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.10</span></div>
    <div class="thm_thmcontent"><p>   We extend standard properties of binary relations to sets of binary conditions: </p>
<p>Say a set of binary conditions \(\sigma \subseteq \mathrm{BiCond}_\alpha \) is <em>total</em> if its domain is \(\mathrm{Cond}_\alpha \); co-total if its range is; and one-to-one if whenever \((x,y,A)\) and \((x',y',A')\) are in \(\sigma \), \(x = x'\) if and only if \(y = y'\). </p>
<p>The <em>dual</em> \(\sigma ^{-1}\) of a set of binary conditions is \(\{  (y,x,A) \mid (x,y,A) \in \sigma \} \). </p>
</div>

    <a class="latex_link" href="sect0001.html#def:condition-total-1-1">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:constrains_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:constrains" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.19</span></div>
    <div class="thm_thmcontent"><p>   Fix a freedom of action context at \(\alpha \). Then the relation \( \prec \) on \(\mathrm{Cond}_\alpha \), read as <em>“constrains”</em>, is defined by: </p>
<ul class="itemize">
  <li><p>\( (L, A) \prec (x, A) \), whenever \( L \) is a litter and \( x \in L \); (an atom is constrained by the litter it belongs to); </p>
</li>
  <li><p>\( (N^\circ , A) \prec (N, A) \) when \( N \) is a near-litter not equal to its corresponding litter \( N^\circ \); </p>
</li>
  <li><p>\( (x, A) \prec (N, A) \) for \(N\) as above and all \( x \in N\, \Delta \,  N^\circ \); </p>
</li>
  <li><p>\( (y, B:(\gamma {\lt}\beta ):A) \prec (L, A) \) for all paths \( A \colon \beta \to \alpha \), and \( \gamma ,\delta {\lt} \beta \), and \( L = f^A_{\gamma ,\delta }(x), x \in \tau _{\gamma :A} \), and \( (y,B) \in S_x \), where \( S_x \subseteq \mathrm{Cond}_\gamma \) is the designated support of \( x \). </p>
</li>
</ul>
<p>Note: “\(x\) constrains \(y\)” is effectively defined separately in the three cases that \(y\) is an atom, a non-litter near-litter, or a non-flexible litter. Flexible litters are not constrained by anything. </p>
<p>Note: This relation is not transitive — that’s OK, it’s not intended to be! </p>
</div>

    <a class="latex_link" href="sect0001.html#def:constrains">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase2/constrains.lean#L59">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:embedding-into-pretangles_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:embedding-into-pretangles" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.27</span></div>
    <div class="thm_thmcontent"><p>  There is an evident injection \(\tau _\alpha \to \mathrm{Pretangle}_\alpha \) (where \(\tau _\alpha \) is constructed from the given tangle data). Moreover, this commutes with the \(\mathrm{All}_\alpha \)-action. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:embedding-into-pretangles">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:f-map_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:f-map" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.3</span></div>
    <div class="thm_thmcontent"><p>   We define, for all \(\beta ,\gamma {\lt} \alpha \), with \(\gamma \) proper, a map \(f_{\beta ,\gamma }\) from \(\tau _\beta \) to \(X_{\beta ,\gamma } \subseteq \mathrm{Litter}\), as follows. </p>
<p>For \(x \in \tau _\beta \), \(f_{\beta ,\gamma }(x)\) is the litter \(N^\circ \) of the minimal near-litter \(N\) (under the ordering induced by \(\iota _\beta \circ j_\beta : \mathcal{NL}\to \tau _\beta \to \mu \)) such that: </p>
<ul class="itemize">
  <li><p>\(N^\circ \in X_{(\beta ,\gamma )}\), i.e. \(N^\circ = L_{(\beta ,\gamma ,i)}\), for some \(i\); </p>
</li>
  <li><p>for each nearby near-litter \(M \sim N\), \(\iota _\gamma (j_\gamma (M)) {\gt}\iota _\beta (x)\); </p>
</li>
  <li><p>\([N] \neq f_{\beta ,\gamma }(y)\), for each \(y {\lt}_\beta x\). </p>
</li>
</ul>
<p>[This can be decomposed slightly at both ends. Firstly, since we know that \(f_{\beta ,\gamma }(x) = (\beta ,\gamma ,\chi )\) for some \(\chi \), we could take the output just to be the component \(\chi \in \mu \), and turn it into a litter later. Secondly, \(f_{\beta _\gamma }(x)\) depends on \(x\) essentially just via its position \(\iota _\beta (x) \in \mu \), so we could start by defining a function \(g_{\beta ,\gamma } : \mu \to \mathrm{Litter}\), and then take \(f_{\beta ,\gamma }\) as the composite \(g_{\beta ,\gamma } \circ \iota _\beta \). I don’t think these will really make a difference either way, though.] </p>
<p>[Notice that this only depends on a small fragment of the tangle data at \(\beta \) and \(\gamma \). In particular, it doesn’t depend on \(\alpha \) nor on the tangle data at other levels. In the formalisation, it would be good to avoid it depending on more than it needs.] </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:f-map">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/f_map.lean#L208">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:flexible-condition_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:flexible-condition" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.13</span></div>
    <div class="thm_thmcontent"><p>   Given a freedom of action context at a proper type index \(\alpha \), a <em>flexible litter</em> is a condition \((L,A)\), with \(L\) a litter, such that \(L\) is not in the image of any of the \(f\)-maps \(f^A_{\gamma ,\delta }\) (for any \(\gamma ,\delta {\lt} \beta \dashrightarrow ^A \alpha \)). </p>
</div>

    <a class="latex_link" href="sect0001.html#def:flexible-condition">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:foa-context_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:foa-context" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.1</span></div>
    <div class="thm_thmcontent"><p>   A <em>freedom of action context</em> at a proper type index \(\alpha \) consists of: </p>
<ol class="enumerate">
  <li><p>for every \(\beta \) and path \(A : \beta \to \alpha \), core tangle data \(\mathrm{All}_A\), \(\tau _A\) etc at \(\beta \); </p>
</li>
  <li><p>for each such \(\beta \), \(A\), when \(A\) is a <em>non-trivial</em> path (equivalently, when \(\beta {\lt} \alpha \)), <em>full</em> tangle data extending the given core data; </p>
</li>
  <li><p>for \(A : \beta \to \alpha \) and \(\gamma {\lt} \beta \), a <em>derivative</em> map \((-)_\gamma : \mathrm{All}_{A} \to \mathrm{All}_{\gamma ;A}\), commuting with the maps \(\mathrm{All}_\bullet \to \mathrm{Str}_\bullet \) and \((-)_{\gamma } : \mathrm{Str}_\beta \to \mathrm{Str}_\gamma \). </p>
</li>
</ol>
<p>Notes: </p>
<ol class="enumerate">
  <li><p>The name “freedom of action context” is very much a placeholder; it would be good to find a better name. </p>
</li>
  <li><p>This can be repackaged several equivalent ways. For instance, the quantification over paths could be re-grouped as “for each \(\beta {\lt} \alpha \) and \(A : \gamma \to \beta \), full tangle data at \(\gamma \); and core tangle data at \(\alpha \)”. This would avoid needing to say “full tangle data extending the given core data”, but would make access to the core data less uniform. </p>
</li>
  <li><p>Viewed categorically, the assumed maps make \(\mathrm{All}\) into a functor on the slice category \((\mathrm{Path}(\lambda ,{\lt})/\alpha )^\mathrm{op}\to \mathrm{Gp}\), making the maps \(\mathrm{All}\to \mathrm{Str}\) a natural transformation. </p>
</li>
  <li><p>The motivation for assuming just “core data” at \(\alpha \) itself is that for the main constructions, we’ll be working in the inductive step of the recursion where we’re assuming the data is already available at lower levels, and by the constructions of phase 1, we can assume some but not all of it is available at the “current level”. </p>
</li>
  <li><p>The motivation for parametrising the lower data not just by levels but by paths is so that when we synthesise this data at \(\alpha \) from similar data at each \(\beta {\lt} \alpha \), no coherence between the given data is required. </p>
</li>
</ol>
</div>

    <a class="latex_link" href="sect0001.html#def:foa-context">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase2/basic.lean#L78">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:foa-property_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:foa-property" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.15</span></div>
    <div class="thm_thmcontent"><p>   Given a freedom of action context at a proper type index \(\alpha \), say that <em>freedom of action holds</em> if for every allowable permutation \(\sigma \), there is some allowable permutation \(\pi \in \mathrm{All}_\alpha \) extending \(\sigma \). </p>
</div>

    <a class="latex_link" href="sect0001.html#def:foa-property">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:local-cardinal_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:local-cardinal" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.7</span></div>
    <div class="thm_thmcontent"><p>   For \(i \in \mathcal{L}\), the \(i\)-th <em>local cardinal</em> \([L_i]\) is \(\{ N \subseteq \tau _{-1}:|N \mathrel {\triangle }L_i|{\lt}\kappa \} \). </p>
<p>For any near-litter \(N\) (including litters), we write \([N]\) for the unique local cardinal that contains \(N\). We introduce the notation \([N]^\circ \) for the litter belonging to the local cardinal of \(N\), with the tacit need to prove that there is only one. </p>
<p>[Note: almost all roles played by local cardinals in the original text should be fulfilled in the formalisation by litter-indices \(i \in \mathcal{L}\).] </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:local-cardinal">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/litter.lean#L194">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:main-recursion_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:main-recursion" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.41</span></div>
    <div class="thm_thmcontent"><p>  For each \(\alpha \in \lambda \), we have the following data: </p>
<ol class="enumerate">
  <li><p>a full freedom of action context \(C_\alpha \) (whose components we write as \(\mathrm{All}^\alpha _A\), \(\tau ^\alpha _A\), etc.), </p>
</li>
  <li><p>such that each restruction \((C_\alpha )_A\) satisfies freedom of action, </p>
</li>
  <li><p>and with \({\lt}\mu \)-many coding functions at the top level. </p>
</li>
</ol>
<p>This data is defined by recursion on \(\alpha \). Given such data for each \(\beta {\lt} \alpha \), </p>
<ol class="enumerate">
  <li><p>the core freedom of action context at \(\alpha \) is synthesised by <a href="sect0001.html#def:synthesise-foa-context">definition 3.3</a> (i.e. using the constructions of phase 1 to give the core tangle data at the top level, and assembling the context at proper paths from the given lower contexts); </p>
</li>
  <li><p>freedom of action at the top level follows by <a href="sect0001.html#thm:foa-propagates">theorem 3.16</a>; </p>
</li>
  <li><p>the top-level coding functions are bounded by <a href="sect0001.html#cor:count-coding-functions">corollary 3.38</a>; </p>
</li>
  <li><p>this allows us to complete the full tangle data at the top level, by <a href="sect0001.html#lem:position-functions-propagate">lemma 3.40</a>. </p>
</li>
</ol>
</div>

    <a class="latex_link" href="sect0001.html#def:main-recursion">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:near-litter_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:near-litter" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.6</span></div>
    <div class="thm_thmcontent"><p>   A <em>near-litter</em> is a subset \(N\) of \(\tau _{-1}\) with small symmetric difference from some litter. This litter is necessarily unique, and we denote it by \(N^\circ \). We write \(\mathcal{NL}\) for the set of all near-litters. </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:near-litter">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/litter.lean#L86">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:params_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:params" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.1</span></div>
    <div class="thm_thmcontent"><p>  Throughout, we fix three parameters: </p>
<ul class="itemize">
  <li><p>\(\lambda \) may be any limit ordinal; </p>
</li>
  <li><p>\(\kappa \) may be any regular cardinal \({\gt}\lambda \); </p>
</li>
  <li><p>\(\mu \) may be any strong limit cardinal \({\gt}\kappa \) of cofinality \(\geq \kappa \). </p>
</li>
</ul>
<p>[Note: The assumptions on \(\kappa \) and \(\mu \) are essential for the construction of the model to work. The assumptions on \(\lambda \) are not needed for this model — everything probably works for an arbitrary well-founded strict partial order \(\lambda \), and gives a model of \(\mathrm{TTT}_\lambda \). The assumption that \(\lambda \) is a limit ordinal is required afterwards, to convert the model of \(\mathrm{TTT}_\lambda \) into a model of \(\mathrm{TST} + \text{typical ambiguity}\).] </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:params">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/params.lean#L41">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:path_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:path" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.4</span></div>
    <div class="thm_thmcontent"><p>   By a <em>path</em>, we mean a path in the directed graph (aka quiver) \((\lambda ^\bot ,{\lt})\); that is, a nonempty finite strictly increasing sequence of type indices \(\alpha _0 {\lt} \cdots {\lt} \alpha _k\). A path is <em>proper</em> if its source (least element) is proper. </p>
<p>We will write paths as \(A : \beta \dashrightarrow \alpha \). We will write path concatenation and extension as \(\gamma ;A\), \(A;B\), and similar. </p>
<p>These may be viewed as the arrows of the free category on \((\lambda ^\bot ,{\lt})\). We mostly avoid using this categorical packaging, to keep things elementary and avoid unnecessary dependencies; but we mention it occasionally in the blueprint, as \(\mathrm{Path}(\lambda ^\bot )\). </p>
<p>[There may be some terminological inconsistency: In places, paths are called <em>extended type indices</em>, and are considered as sets rather than sequences; also, they are sometimes taken to be decreasing instead of increasing.] </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:path">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/index.lean#L123">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:pretangle_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:pretangle" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.10</span></div>
    <div class="thm_thmcontent"><p>   Define the sets \(\mathrm{Pretangle}_\alpha \) of <em>\(\alpha \)-pretangles</em> inductively. \(\mathrm{Pretangle}_{-1}\) is defined as \(\tau _{-1}\). For \(\alpha \) a proper type index, \(\mathrm{Pretangle}_\alpha \) is defined as \(\prod _{\beta {\lt} \alpha } \mathcal P(\mathrm{Pretangle}_\beta )\). </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:pretangle">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/pretangle.lean#L16">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:restrict-foa-context_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:restrict-foa-context" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.2</span></div>
    <div class="thm_thmcontent"><p>  Given a freedom of action context at \(\alpha \) and a path \(A : \beta \to \alpha \), we can restrict the context along \(A\) to get a freedom of action context at \(\beta \). Moreover, this is functorial in \(A\). Note, in the Lean implementation, instead of ‘restricting along \(A\)’, we parametrise many of our functions by a parameter \(B\), which is some path from a type index to \(\alpha \). </p>
</div>

    <a class="latex_link" href="sect0001.html#def:restrict-foa-context">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:semi-tangle_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:semi-tangle" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.12</span></div>
    <div class="thm_thmcontent"><p>   An <em>\(\alpha \)-semi-tangle</em> is an element \(x\) of \(\prod _{\beta {\lt} \alpha }\mathcal P(\tau _\beta ) \times (\alpha + \mathcal P(\tau _{-1}))\), whose components we denote \(x_\beta \), such that: </p>
<ul class="itemize">
  <li><p>if \(x_{-1}\) is some \(\beta {\lt} \alpha \), then \((\alpha ,\beta ,x_\beta )\) is a representative code, and for each other \(\gamma \), \(A_{\beta ,\gamma }(\alpha ,\beta ,x_\beta ) = (\alpha ,\gamma ,x_\gamma )\); </p>
</li>
  <li><p>if \(x_{-1}\) is a set of atoms, then \((\alpha ,-1,x_{-1})\) is a representative code, and for each other \(\gamma \), \(A_{-1,\gamma }(\alpha ,-1,x_{-1}) = (\alpha ,\gamma ,x_\gamma )\); </p>
</li>
</ul>
<p>[Note that these are intermediate between “pretangles” and “tangles”. Also note that — as with pretangles — we probably don’t need the “preferred extension” component.] </p>
<p>[Actually it’s probably simpler to go back to representing these as representative codes for now, and just define here the components \(x_\beta \), for later embedding them into pretangles. It’s only in phase 2 that the embedding into pretangles will really become helpful!] </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:semi-tangle">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/tangle.lean#L64">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:semi-tangle-action_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:semi-tangle-action" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.20</span></div>
    <div class="thm_thmcontent"><p>   Allowable permutations act on semi-tangles. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:semi-tangle-action">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/tangle.lean#L314">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:semiallowable-perm_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:semiallowable-perm" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.15</span></div>
    <div class="thm_thmcontent"><p>   A <em>semi-allowable permutation</em> at level \(\alpha \) is a family of allowable pemutations at all lower levels (including \(-1\)), \((\pi _\beta )_{\beta {\lt} \alpha } \in \prod _{\beta {\lt} \alpha } \mathrm{All}_\beta \). </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:semiallowable-perm">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/allowable.lean#L27">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:small_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:small" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.2</span></div>
    <div class="thm_thmcontent"><p>   We refer to sets of size smaller than \(\kappa \) as <em>small</em> [and all other sets as large]. </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:small">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/params.lean#L270">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:strong-support_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:strong-support" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.25</span></div>
    <div class="thm_thmcontent"><p>  A <em>strong support</em> is a support \(S\) equipped with a well-ordering \(\prec _S\), such that whenever \(c \in S\) and \(d\) constrains \(c\), then \(d \in S\) and \(d \prec _S c\). </p>
</div>

    <a class="latex_link" href="sect0001.html#def:strong-support">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:struct-perm-extends_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:struct-perm-extends" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.7</span></div>
    <div class="thm_thmcontent"><p>   We say that a structural permutation \(\pi \) <em>extends</em> a set of binary conditions \(\sigma \) if \(\sigma \subseteq \pi \), viewing \(\pi \) as its graph. More generally, given any group with a map \(\varphi : G \to \mathrm{Str}\) (e.g. the allowable permutations of some tangle data), we say \(\pi \in G\) extends a set of binary conditions \(\sigma \) if \(\sigma \subseteq \varphi (\pi )\). </p>
</div>

    <a class="latex_link" href="sect0001.html#def:struct-perm-extends">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:struct-perm-graph_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:struct-perm-graph" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.6</span></div>
    <div class="thm_thmcontent"><p>   A binary condition \((x,y,A)\) is viewed as representing the condition “\(\pi _A(x) = y\)”. Any \(\alpha \)-structural permutation \(\pi \) thus induces a set of binary conditions, its <em>graph</em>, \(\{  (x,y,A) \in \mathrm{BiCond}_\alpha \mid \pi _A(x) = y \} \). This gives an evident embedding \(\mathrm{Str}_\alpha \to \mathcal{P}(\mathrm{BiCond}_\alpha )\); we will notationally identify structural permutations with their graphs. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:struct-perm-graph">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:structural-perm_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:structural-perm" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.12</span></div>
    <div class="thm_thmcontent"><p>   For a <em>proper</em> type index \(\alpha \), the structural \(\alpha \)-permutations are the group \(\mathrm{Str}_\alpha = \prod _{\beta {\lt} \alpha } \mathrm{Str}_\beta \). </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:structural-perm">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/struct_perm.lean#L31">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:structural-perm-atoms_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:structural-perm-atoms" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.11</span></div>
    <div class="thm_thmcontent">
<p>A <em>structural \((-1)\)-permutation</em> [aka a near-litter-perm; we should fix on one name or the other] is a permutation \(\pi \) of \(\tau _{-1}\), along with a permutation \(\bar{\pi }\) of litters, such that for each litter \(L\), \(\pi ``(L)\) is near to \(\bar{\pi }(L)\) (in the sense that they have small symmetric difference). Denote the group of these by \(\mathrm{Str}_{-1}\). </p>
<p>[In fact \(\bar{\pi }\) is uniquely determined by \(\pi \) — we could define this just as a subgroup of \(\mathrm{Sym}(\tau _{-1})\). But it’s convenient in formalisation to have the \(\bar{\pi }\) component explicit.] </p>
<p>\(\mathrm{Str}_{-1}\) has obvious actions on atoms and near-litters. </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:structural-perm-atoms">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/litter.lean#L276">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:structural-perm-derivative_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:structural-perm-derivative" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.13</span></div>
    <div class="thm_thmcontent"><p>   Any path \(A : \beta \dashrightarrow \alpha \) gives a group homomorphism \((-)_A : \mathrm{Str}_\alpha \to \mathrm{Str}_\beta \). </p>
<p>Moreover, this is functorial: they make \(\mathrm{Str}\) into a functor \(\mathrm{Path}(\lambda ^\bot )^\mathrm{op}\to \mathrm{Gp}\). </p>
<p>[TODO: this should also depend on “paths”, but they aren’t yet explicitly in the blueprint.] </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:structural-perm-derivative">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/struct_perm.lean#L143">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:support_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:support" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.17</span></div>
    <div class="thm_thmcontent"><p>   Let \(\alpha \) be a proper type index. An \(\alpha \)-support is a small set of \(\alpha \)-support-conditions. (A little more pedantically, one could call these something like “potential small supports”: they become actual supports once they support some element.) </p>
<p>[NOTES for formalisation: Well-orderings are assumed here in some version of Randall’s note, but they almost certainly aren’t wanted in the basic definition of supports, as used in phase 1. Strong supports, as used in phase 2, are probably better viewed as a separate notion: a more elaborate data structure that can be used to “present” a support in a particularly good way.] </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:support">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/support.lean#L73">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:support-condition_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:support-condition" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.15</span></div>
    <div class="thm_thmcontent"><p>   Let \(\alpha \) be a proper type index. An <em>\(\alpha \)-support-condition</em> (or just <em>\(alpha\)-condition</em>) is a pair \((x,A)\), where \(A\) is a path from \(-1\) to \(\alpha \) (aka an extended type index) and \(x\) is either an atom or a near-litter. </p>
<p>Type-theoretically, \(\mathrm{Cond}_\alpha := (\tau _{-1} + \mathcal{NL}) \times \mathrm{Path}(-1,\alpha )\). </p>
<p>[It would suffice to use just litters here instead of near-litters; they give an equivalent notion of support, as shown later (“replacing near-litters with litters”). That makes a few things simpler; but using near-litters lets us talk about the action, Def.&#160;<a href="ch-preliminaries.html#def:support-condition-action">1.16</a>, which seems algebraically cleaner.] </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:support-condition">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/support.lean#L20">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:support-condition-action_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:support-condition-action" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.16</span></div>
    <div class="thm_thmcontent"><p>   Structural permutations act on support conditions. </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:support-condition-action">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/support.lean#L41">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:support-of_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:support-of" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.18</span></div>
    <div class="thm_thmcontent"><p>   Suppose \(\varphi : H \to \mathrm{Str}_\alpha \) is any group homomorphism, and \(\tau \) is a set equipped with an \(H\)-action. </p>
<p>Given \(x \in \tau \) and \(S\) any set of \(\alpha \)-support conditions, say <em>\(S\) supports \(x\)</em> if every \(\pi \in H\) that fixes every element of \(S\) also fixes \(x\). </p>
<p>A <em>support for \(x\)</em> is a support (i.e. a <em>small</em> set of conditions) that supports \(x\). [Should we try to always say “small support” to avoid ambiguity?] </p>
<p>We say \(x\) is <em>symmetric</em> if it has some small support. </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:support-of">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:support-spec_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:support-spec" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.28</span></div>
    <div class="thm_thmcontent"><p>  Fix a freedom of action context for \(\alpha \). A <em>support-specification</em> is …[this is quite long to define; we should get the text from more recent versions of Randall’s note] </p>
</div>

    <a class="latex_link" href="sect0001.html#def:support-spec">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:support-spec-realisation_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:support-spec-realisation" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.30</span></div>
    <div class="thm_thmcontent"><p>  Any support specification can be realised (non-uniquely) to give a strong support. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:support-spec-realisation">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:synthesise-foa-context_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:synthesise-foa-context" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.3</span></div>
    <div class="thm_thmcontent"><p>  Given \(\alpha \in \lambda \), and a freedom of action context at each \(\beta {\lt} \alpha \), together with extensions of their top-level core tangle data to full tangle data at each \(\beta {\lt} \alpha \), there is a <em>synthesised</em> freedom of action context at \(\alpha \), with its top-level core tangle data given by the constructions of phase 1. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:synthesise-foa-context">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:tangle_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:tangle" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.21</span></div>
    <div class="thm_thmcontent"><p>   We take the set of \(\alpha \)-tangles, \(\tau _\alpha \), to be the set of <em>symmetric</em> \(\alpha \)-semi-tangles under the action of allowable permutations; that is, tangles that are supported by some small \(\alpha \)-support \(S\),. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:tangle">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/tangle.lean#L347">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:tangle-completed_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:tangle-completed" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3.42</span></div>
    <div class="thm_thmcontent"><p>  The (actual, genuine, definitive!) tangles are the structure \(\mathrm{Tangle}\) extracted from the freedom of action contexts defined in <a href="sect0001.html#def:main-recursion">definition 3.41</a> as follows: </p>
<ol class="enumerate">
  <li><p>\(\tau _\alpha \) is the top-level tangles of the freedom of action context at \(\alpha \); </p>
</li>
  <li><p>“by construction” (i.e. by the defining clause of <a href="sect0001.html#def:main-recursion">definition 3.41</a>), \(\tau _\alpha \) is constructed by <a href="ch-model-construction.html#def:tangle">definition 2.21</a> from the tangles \(\tau _\beta \) for \(\beta {\lt} \alpha \); thus <a href="ch-model-construction.html#def:ttt-membership">definition 2.13</a> gives a membership relation \(\in _{\beta ,\alpha }\) from \(\tau _\beta \) to \(\tau _\alpha \), for each \(\beta {\lt} \alpha \). </p>
</li>
</ol>
<p>[Note: The definition of \(\in _{\beta ,\alpha }\) uses a type equality on \(\tau _\alpha \), so may not be very nice to work with directly in subsequenet lemmas. However, it’s hard to see how any approach to this inductively constructed structure could avoid such issues. When we get to this stage, we can think about how to deal with this issue.] </p>
</div>

    <a class="latex_link" href="sect0001.html#def:tangle-completed">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:tangle-data_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:tangle-data" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.1</span></div>
    <div class="thm_thmcontent">
<p>Fix a proper type index \(\alpha \). Then <em>tangle data at \(\alpha \)</em> consists of: </p>
<ol class="enumerate">
  <li><p>a group \(\mathrm{All}\) (whose elements we call <em>allowable permutations</em>), with a map \(\varphi : \mathrm{All}\to \mathrm{Str}_\alpha \); </p>
</li>
  <li><p>a set \(\tau \) (whose elements we call <em>tangles</em>), equipped with an \(\mathrm{All}\)-action; </p>
</li>
  <li><p>a map \(j\) (<em>typed near-litters</em>) from near-litters to \(\tau \), equivariant with respect to the \(\mathrm{All}\)-action on near-litters induced by \(\mathrm{All}\to \mathrm{Str}_{\alpha } \to \mathrm{Str}_{-1}\); </p>
</li>
  <li><p>a map \(k\) (<em>typed singletons</em>) from \(\tau _{-1}\) to \(\tau \), again \(\mathrm{All}\)-equivariant w.r.t. the induced action on \(\tau _{-1}\); </p>
</li>
  <li><p>for each \(x \in \tau \), a small set \(S_x\) of \(\alpha \)-support-conditions that supports \(x\) under the \(\mathrm{All}\)-action (a <em>designated support</em> for \(x\)); </p>
</li>
  <li><p>an injection \(\iota : \tau \to \mu \), satisfying the following conditions: </p>
<ol class="enumerate">
  <li><p>each typed litter \(j(L)\) precedes the typed singletons of all its elements \(a \in L\) — explicitly, \(\iota (j(L)) {\lt} \iota (k(a))\); </p>
</li>
  <li><p>each typed near-litter \(k(N)\) which is not a litter comes later than its (typed) litter \(j(N^\circ )\), and after (the typed singletons of) all elements of \(N \mathrel {\triangle }N^\circ \); </p>
</li>
  <li><p>for each \(x\) in \(\tau _\alpha \) that is not a typed litter or singleton, \(x\) comes later than all of its designated support – explicitly, for each \((a,A)\) or \((N,A)\) in \(S_x\), we must have \(\iota _\alpha (j(N)), \iota _\alpha (k(a)){\lt}\iota _\alpha (x)\). </p>
</li>
</ol>
<p> [Note: to see these conditions are not unreasonable, note that each \(x \in \tau \) has \({\lt}\mu \) many things that it must come after, and that the chains of these constraints are of depth at most 4: litters \({\lt}\) atoms \({\lt}\) other near-litters \({\lt}\) everything else. This is said more carefully in <a href="sect0001.html#lem:position-functions-propagate">lemma 3.40</a> below.] </p>
</li>
  <li><p>[Optionally: An injection \(\tau \to \mathrm{Pretangle}_\alpha \), equivariant with respect to the induced \(\mathrm{All}\)-action. This may or may not be needed, depending on how the phase 2 data is organised.] </p>
</li>
</ol>
<p>By <em>core tangle data</em>, we will mean just \(\mathrm{All}\), \(\varphi \), \(\tau \), and the \(\mathrm{All}\)-action on \(\tau \) as above. By <em>incomplete tangle data</em>, we will mean all the above data except for the position functions \(\iota \) and their properties. </p>
<p>When we assume this data at multiple levels, we will refer to the components \(\tau _\beta \), \(\mathrm{All}_\beta \), and so on, and call their elements \(\alpha \)-tangles, etc. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:tangle-data">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/basic.lean#L142">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:tangle-data-propagates_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:tangle-data-propagates" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.28</span></div>
    <div class="thm_thmcontent"><p>  For a proper type index \(\alpha \in \lambda \), given tangle data at all levels \(\beta {\lt} \alpha \), then the constructions above provide <em>most</em> components of tangle data at level \(\alpha \) — everything except for the embedding \(\iota _\alpha : \tau _\alpha \to \mu \) and its properties. </p>
<p>[Note that to treat this as a <em>definition</em>, in particular of the “designated supports” component, we are implicitly invoking the axiom of choice — a priori we only know that there <em>exists</em> some support for each new tangle.] </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:tangle-data-propagates">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:ttt-membership_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:ttt-membership" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.13</span></div>
    <div class="thm_thmcontent"><p>   Membership relations of \(\alpha \)-semi-tangles, for the intended model of tangled type theory, can now be defined as follows: for each proper type index \(\beta {\lt} \alpha \), and \(x \in \tau _\beta \), and each \(\alpha \)-semi-tangle \(y \in \tau _\alpha \), say \(x \in _{TTT} y\) just if \(x \in y_\beta \). </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:ttt-membership">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/tangle.lean#L72">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:type-index_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:type-index" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1.3</span></div>
    <div class="thm_thmcontent"><p>   We define a <em>type index</em> as an element of \(\lambda ^\bot := \lambda \cup \{ -1\} \). We define a <em>proper type index</em> as an element of \(\lambda \). </p>
<p>In many ways, \(-1\) should be viewed as a type index on the same footing as other elements of \(\lambda \); but it frequently needs treating as a special case. </p>
<p>[In the formalisation, “\(-1\)” is referred to as \(\bot \). Should we consider following that in the text too?] </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#def:type-index">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/params.lean#L179">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:typed-near-litter_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:typed-near-litter" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.23</span></div>
    <div class="thm_thmcontent"><p>   Any code \((\alpha ,-1,N)\), where \(N\) is a near-litter, gives an element of \(\tau _\alpha \). </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:typed-near-litter">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:typed-singleton_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:typed-singleton" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.24</span></div>
    <div class="thm_thmcontent"><p>   For any symmetric \(b \in \tau _\beta \), \((\alpha ,\beta ,\{ b\} ) \in \tau _\alpha \). In particular, this works for each atom \(a \in \tau _{-1}\). </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#def:typed-singleton">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:a-map-properties_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:a-map-properties" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.6</span></div>
    <div class="thm_thmcontent">
<ol class="enumerate">
  <li><p>Each \(A_\delta \) is injective on nonempty codes. </p>
</li>
  <li><p>The ranges of \(A_\delta \) are disjoint for different \(\delta \). </p>
</li>
</ol>
<p>NB: The disjointness of ranges depends on excluding the empty set — either from the domains of the \(A_\delta \) from the start, or else in the statement of this lemma. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:a-map-properties">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/A_map.lean#L105">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:a-map-wf_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:a-map-wf" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.7</span></div>
    <div class="thm_thmcontent"><p>   The relation \(c \rightsquigarrow d\) on codes (“\(c\) leads to \(d\) under some \(A\)-map”) is well-founded. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:a-map-wf">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/A_map.lean#L330">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:code-equiv-properties_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:code-equiv-properties" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.11</span></div>
    <div class="thm_thmcontent"><p>   Under \(\equiv _\alpha \), each code is equivalent to </p>
<ol class="enumerate">
  <li><p>exactly one even code </p>
</li>
  <li><p>exactly one code of extension \(\gamma \) for all \(\gamma \ne -1\), \(\gamma {\lt} \alpha \) </p>
</li>
  <li><p>at most one code of extension \(-1\) </p>
</li>
</ol>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:code-equiv-properties">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/code_equiv.lean#L370">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:code-parity-properties_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:code-parity-properties" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.9</span></div>
    <div class="thm_thmcontent">
<ol class="enumerate">
  <li><p>All codes are even or odd. </p>
</li>
  <li><p>An odd nonempty code only leads to even codes. </p>
</li>
</ol>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:code-parity-properties">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/code_equiv.lean#L132">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:coding-function-has-spec_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:coding-function-has-spec" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.37</span></div>
    <div class="thm_thmcontent"><p>  Every coding function can be obtained as the realisation of some specification </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:coding-function-has-spec">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:coherence-unpacked_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:coherence-unpacked" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.18</span></div>
    <div class="thm_thmcontent"><p>   A semi-allowable permutation \(\pi \) is allowable just if </p>
<div class="displaymath" id="a0000000033">
  \[ f_{\gamma ,\delta }(\pi _\gamma (g)) = [(\pi _\delta )_{-1}``f_{\gamma ,\delta }(g)^\circ ]. \]
</div>
<p> holds for all \(f_{\gamma ,\delta }\) with \(\gamma ,\delta {\lt}\alpha \), and all \(g \in \tau _\gamma \). </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:coherence-unpacked">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/allowable.lean#L184">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:count-coding-function-specs_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:count-coding-function-specs" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.35</span></div>
    <div class="thm_thmcontent"><p>  There are \({\lt}\mu \)-many coding function specifications. </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:count-coding-function-specs">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:count-near-litters_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:count-near-litters" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">1.9</span></div>
    <div class="thm_thmcontent"><p>   Because the cofinality of \(\mu \) is \(\geq \kappa \), there are \(\mu \) near-litters. </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#lem:count-near-litters">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/litter.lean#L189">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:count-support-specs_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:count-support-specs" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.29</span></div>
    <div class="thm_thmcontent"><p>  There are \({\lt}\mu \)-many support specifications. </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:count-support-specs">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:count-supports_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:count-supports" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">1.19</span></div>
    <div class="thm_thmcontent"><p>   Because the cofinality of \(\mu \) is \(\geq \kappa \), there are \(\mu \) potential supports, and therefore at most \(\mu \) supports for each \(x \in \tau \). </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#lem:count-supports">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:f-map-properties_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:f-map-properties" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.4</span></div>
    <div class="thm_thmcontent"><p>   The maps \(f_{\beta ,\gamma }\) satisfy: </p>
<ol class="enumerate">
  <li><p>each \(f_{\beta ,\gamma }\) is injective; </p>
</li>
  <li><p>their images are disjoint, for all different pairs \((\beta ,\gamma )\); </p>
</li>
  <li><p>each \(f_{\beta ,\gamma }\) is “position-raising”: \(\iota _\gamma (j_\gamma (N)) {\gt} \iota _\beta (x)\), for any near-litter \(N\) near to the litter \(L_{(\beta ,\gamma ,f_{\beta ,\gamma }(x))}\). </p>
</li>
</ol>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:f-map-properties">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/f_map.lean#L214">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:maximal-allowable-partial-perm-total_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:maximal-allowable-partial-perm-total" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.23</span></div>
    <div class="thm_thmcontent"><p>   Any allowable partial permutation that is maximal under \(\sqsubseteq \) is total. </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:maximal-allowable-partial-perm-total">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:parity-action_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:parity-action" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.19</span></div>
    <div class="thm_thmcontent"><p>  The action of allowable permutations on codes preserves parity. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:parity-action">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/allowable.lean#L283">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:position-functions-propagate_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:position-functions-propagate" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.40</span></div>
    <div class="thm_thmcontent"><p>  Given a freedom of action context for \(\alpha \) satisfying freedom of action at \(\alpha \), we can choose supports \(S(x)\) for all \(\alpha \)-tangles \(x\) and a position function \(\iota _\alpha : \tau _\alpha \to \mu \) satisfying the conditions demanded in <a href="ch-model-construction.html#def:tangle-data">definition 2.1</a>: </p>
<ol class="enumerate">
  <li><p>for each litter \(L\), the typed litter of \(L\) precedes the typed singletons of all its elements \(a \in L\) — explicitly, \(\iota (j(L)) {\lt} \iota (k(a))\); </p>
</li>
  <li><p>for each near-litter \(N\) which is not a litter, \(j(N)\) comes after its (typed) litter \(j(N^\circ )\), and after (the typed singletons of) all elements of \(N \mathrel {\triangle }N^\circ \); </p>
</li>
  <li><p>for each \(x\) in \(\tau _\alpha \) that is not a typed litter or singleton, \(x\) comes later than all of its designated support – explicitly, for each \((a,A)\) or \((N,A)\) in the in \(S(x)\), we must have \(\iota _\alpha (j(N)), \iota _\alpha (k(a)){\lt}\iota _\alpha (x)\). </p>
</li>
</ol>
</div>

    <a class="latex_link" href="sect0001.html#lem:position-functions-propagate">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:small-diff-equiv_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:small-diff-equiv" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">1.8</span></div>
    <div class="thm_thmcontent"><p>   Note that \(\mathcal{L}\) corresponds to the equivalence classes of an equivalence relation \(\sim \) on near-litters, where \(X \sim Y\) iff the symmetric difference \(X \mathrel {\triangle }Y\) is small. </p>
</div>

    <a class="latex_link" href="ch-preliminaries.html#lem:small-diff-equiv">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase0/params.lean#L352">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:small-subsets-closure_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:small-subsets-closure" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.25</span></div>
    <div class="thm_thmcontent"><p>   It should also be evident that \((\alpha ,\beta ,B)\) will always be symmetric if \(|B|{\lt}\kappa \) [take the union of the \(\beta \)-supports of elements of \(B\) and add \(\alpha \) to all the second components of elements of this union]: all small subsets of a type are realized in each higher type. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:small-subsets-closure">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:strengthen-support_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:strengthen-support" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.26</span></div>
    <div class="thm_thmcontent"><p>  Any support is a subset of some strong support (and hence any tangle is supported by some strong support). </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:strengthen-support">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:strong-support-has-spec_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:strong-support-has-spec" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.32</span></div>
    <div class="thm_thmcontent"><p>  Every strong support can be obtained as the realisation of some specification </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:strong-support-has-spec">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:support-spec-realisation-unique_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:support-spec-realisation-unique" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">3.31</span></div>
    <div class="thm_thmcontent"><p>  If freedom of action holds at \(\alpha \), then realisations of a support specification are unique modulo the group action. That is, for any two realisations \(S, S'\) of a support specification \(S\), there is some allowable permutation \(\pi \) such that \(\pi S = S'\). </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:support-spec-realisation-unique">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:supportedness-equiv_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:supportedness-equiv" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.22</span></div>
    <div class="thm_thmcontent"><p>  If \(X \subseteq \tau _\beta \), \(Y \subseteq \tau _\gamma \), and \((\alpha ,\beta ,X) \equiv _\alpha (\alpha ,\gamma ,Y)\), then (under the action of allowable permutations on codes) a set \(S\) of conditions supports \(\beta \) if and only if it supports \(\gamma \). In particular, \((\alpha ,\beta ,X)\) has some small support if and only if \((\alpha ,\gamma ,Y)\) does. </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:supportedness-equiv">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:tangle-action_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:tangle-action" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">2.26</span></div>
    <div class="thm_thmcontent"><p>   The action of \(\alpha \)-allowable permutations on semi-tangles restricts to an action on tangles. Explicitly, if an \(\alpha \) semi-tangle \(x\) is symmetric, then so is \(\pi x\) for any \(\alpha \)-allowable permutation \(\pi \). </p>
</div>

    <a class="latex_link" href="ch-model-construction.html#lem:tangle-action">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/tangle.lean#L484">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:allowable-partial-perm-action_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:allowable-partial-perm-action" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.22</span></div>
    <div class="thm_thmcontent"><p>   Given a freedom of action context at a proper type index \(\alpha \), an allowable permuation \(\sigma \), and an \(\alpha \)-tangle \(x\) such that \(\mathrm{dom}\sigma \) supports \(x\): </p>
<ol class="enumerate">
  <li><p>if \(\pi , \pi ' \in \mathrm{All}_\alpha \) are allowable permutations extending \(\sigma \), then \(\pi x = \pi ' x\); </p>
</li>
  <li><p>if freedom of action holds, there is a unique \(y \in \tau _\alpha \) such that every allowable permutation \(\pi \) extending \(\sigma \) has \(\pi x = y\); we denote this unique value by \(\sigma x\). </p>
</li>
</ol>
</div>

    <a class="latex_link" href="sect0001.html#prop:allowable-partial-perm-action">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:allowable-partial-perm-chain-union_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:allowable-partial-perm-chain-union" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.18</span></div>
    <div class="thm_thmcontent"><p>   \(\sqsubseteq \) has upper bounds for chains, given by taking unions. That is: given a set of allowable partial permutations that is a chain under \(\sqsubseteq \), its union is again an allowable partial permutation, and carefully extends each element of the chain. (Indeed, this gives a supremum for the chain, and so shows that \(\sqsubseteq \) is chain-complete; but “upper bounds” is all we need in order to apply Zorn’s lemma.) </p>
</div>

    <a class="latex_link" href="sect0001.html#prop:allowable-partial-perm-chain-union">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:conditions-from-perm-restriction_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:conditions-from-perm-restriction" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.8</span></div>
    <div class="thm_thmcontent"><p>   This identification of permutations respects the actions of paths. That is, given a structural permutation \(\pi \), the graph of the derivative \(\pi _A\) is precisely the restriction along \(A\) of the graph of \(\pi \) (as our notational identification suggests). </p>
</div>

    <a class="latex_link" href="sect0001.html#prop:conditions-from-perm-restriction">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:constrains-well-founded_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:constrains-well-founded" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.20</span></div>
    <div class="thm_thmcontent"><p>   The relation \( \prec \) is well-founded. </p>
</div>

    <a class="latex_link" href="sect0001.html#prop:constrains-well-founded">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase2/constrains.lean#L111">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:restrict-allowable-partial-perm_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:restrict-allowable-partial-perm" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.21</span></div>
    <div class="thm_thmcontent"><p>   If \(\sigma \) is an allowable permutation in a freedom of action context at \(\alpha \), then for any \(A : \beta \to \alpha \), the restriction \(\sigma _A\) is again allowable in the context restricted along \(A\). </p>
</div>

    <a class="latex_link" href="sect0001.html#prop:restrict-allowable-partial-perm">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:total-1-1-gives-perm_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:total-1-1-gives-perm" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.11</span></div>
    <div class="thm_thmcontent"><p>   A set of binary conditions is the graph of a structural permutation precisely if it is one-to-one and total. </p>
<p>(NOTE: this may not be explicitly needed, but it is helpful to know, and should be a good warmup and definition-test ahead of the main freedom of action theorem, in particular <a href="sect0001.html#prop:total-allowable-partial-perm-actual">proposition 3.24</a>.) </p>
</div>

    <a class="latex_link" href="sect0001.html#prop:total-1-1-gives-perm">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:total-1-1-restriction_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:total-1-1-restriction" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.12</span></div>
    <div class="thm_thmcontent"><p>  If a set of \(\alpha \)-conditions \(\sigma \) is total (resp. co-total, 1-1) then so is its restriction \(\sigma _A\) for any path \(A : \beta \to \alpha \). </p>
</div>

    <a class="latex_link" href="sect0001.html#prop:total-1-1-restriction">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="prop:total-allowable-partial-perm-actual_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="prop:total-allowable-partial-perm-actual" style="display: none">
    <div class="thm_thmheading">
      <span class="proposition_thmcaption">
      Proposition
      </span>
      <span class="proposition_thmlabel">3.24</span></div>
    <div class="thm_thmcontent"><p>   In the synthesised freedom of action context at \(\alpha \), any partial allowable permutation (at \(\alpha \)) that is total and co-total extends to an actual allowable permutation at \(\alpha \). </p>
</div>

    <a class="latex_link" href="sect0001.html#prop:total-allowable-partial-perm-actual">LaTeX</a>
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="thm:extensionality_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="thm:extensionality" style="display: none">
    <div class="thm_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.14</span></div>
    <div class="thm_thmcontent"><p>   For all proper type indices \(\beta {\lt} \alpha \), \(\beta \)-tangles \(x\), and \(\alpha \)-semitangles \(y\), the following (nearly-obviously equivalent) statements hold: </p>
<ul class="itemize">
  <li><p>if for all \(z \in \tau _\beta \), \((z \in _{\tt TTT} x \leftrightarrow z \in _{\tt TTT} y)\), then \(x=y\); </p>
</li>
  <li><p>if \(x_\beta = y_\beta \), then \(x=y\). </p>
</li>
</ul>
</div>

    <a class="latex_link" href="ch-model-construction.html#thm:extensionality">LaTeX</a>
  <a class="lean_link" href="https://github.com/leanprover-community/con-nf//blob/f0b66bd73ca5d3bd8b744985242c4c0b5464913f/src/phase1/tangle.lean#L167">Lean</a></div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="thm:foa-propagates_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="thm:foa-propagates" style="display: none">
    <div class="thm_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">3.16</span></div>
    <div class="thm_thmcontent"><p>   Suppose given, for each \(\beta {\lt} \alpha \), a freedom of action context together with full tangle data at the top level; and such that for all their restrictions along any path \(A : \gamma \to \beta \) (including identity paths), freedom of action holds. </p>
<p>Then freedom of action holds in the synthesised freedom of action context at \(\alpha \) (i.e. with the tangles and allowable permutations at \(\alpha \) defined by the constructions of phase 1). </p>
</div>

    <a class="latex_link" href="sect0001.html#thm:foa-propagates">LaTeX</a>
  </div>
    
      </div>
    </div>
</div>
</div> <!-- content -->
</div> <!-- wrapper -->
<script src="js/jquery.min.js" type="text/javascript"></script>

<script src="js/d3.min.js"></script>
<script src="js/hpcc.min.js"></script>
<script src="js/d3-graphviz.js"></script>

<script type="text/javascript">
const graphContainer = d3.select("#graph");
const width = graphContainer.node().clientWidth;
const height = graphContainer.node().clientHeight;


graphContainer.graphviz({useWorker: true})
    .width(width)
    .height(height)
    .fit(true)
    .renderDot('strict digraph "" {	graph [bgcolor=transparent];	node [label="\N",		penwidth=1.8	];	edge [arrowhead=vee];	"def:params"	[color=green,		fillcolor="#b0eca3",		label=params,		shape=box,		style=filled];	"def:small"	[color=green,		fillcolor="#b0eca3",		label=small,		shape=box,		style=filled];	"def:params" -> "def:small"	[style=dashed];	"def:type-index"	[color=green,		fillcolor="#b0eca3",		label="type-index",		shape=box,		style=filled];	"def:params" -> "def:type-index"	[style=dashed];	"def:atoms-and-litters"	[color=green,		fillcolor="#b0eca3",		label="atoms-and-litters",		shape=box,		style=filled];	"def:params" -> "def:atoms-and-litters"	[style=dashed];	"def:ttt-membership"	[color=green,		fillcolor="#b0eca3",		label="ttt-membership",		shape=box,		style=filled];	"thm:extensionality"	[color=green,		fillcolor="#9cec8b",		label=extensionality,		shape=ellipse,		style=filled];	"def:ttt-membership" -> "thm:extensionality"	[style=dashed];	"def:binary-condition"	[color=green,		fillcolor="#b0eca3",		label="binary-condition",		shape=box,		style=filled];	"def:condition-functoriality"	[color=green,		fillcolor="#b0eca3",		label="condition-functoriality",		shape=box,		style=filled];	"def:binary-condition" -> "def:condition-functoriality"	[style=dashed];	"def:condition-dom-rge"	[color=green,		fillcolor="#b0eca3",		label="condition-dom-rge",		shape=box,		style=filled];	"def:binary-condition" -> "def:condition-dom-rge"	[style=dashed];	"def:struct-perm-extends"	[color=green,		fillcolor="#b0eca3",		label="struct-perm-extends",		shape=box,		style=filled];	"def:binary-condition" -> "def:struct-perm-extends"	[style=dashed];	"def:struct-perm-graph"	[color=green,		fillcolor="#b0eca3",		label="struct-perm-graph",		shape=box,		style=filled];	"def:binary-condition" -> "def:struct-perm-graph"	[style=dashed];	"def:constrains"	[color=blue,		label=constrains,		shape=box];	"def:strong-support"	[label="strong-support",		shape=box];	"def:constrains" -> "def:strong-support"	[style=dashed];	"prop:constrains-well-founded"	[color=green,		fillcolor="#a3d6ff",		label="constrains-well-founded",		shape=ellipse,		style=filled];	"def:constrains" -> "prop:constrains-well-founded"	[style=dashed];	"lem:strong-support-has-spec"	[label="strong-support-has-spec",		shape=ellipse];	"lem:coding-function-has-spec"	[label="coding-function-has-spec",		shape=ellipse];	"lem:strong-support-has-spec" -> "lem:coding-function-has-spec";	"cor:count-strong-supports"	[label="count-strong-supports",		shape=ellipse];	"lem:strong-support-has-spec" -> "cor:count-strong-supports";	"lem:a-map-wf"	[color=green,		fillcolor="#9cec8b",		label="a-map-wf",		shape=ellipse,		style=filled];	"lem:code-parity-properties"	[color=green,		fillcolor="#9cec8b",		label="code-parity-properties",		shape=ellipse,		style=filled];	"lem:a-map-wf" -> "lem:code-parity-properties";	"lem:small-diff-equiv"	[color=green,		fillcolor="#9cec8b",		label="small-diff-equiv",		shape=ellipse,		style=filled];	"def:small" -> "lem:small-diff-equiv"	[style=dashed];	"def:near-litter"	[color=green,		fillcolor="#b0eca3",		label="near-litter",		shape=box,		style=filled];	"def:small" -> "def:near-litter"	[style=dashed];	"def:structural-perm-atoms"	[color=green,		fillcolor="#b0eca3",		label="structural-perm-atoms",		shape=box,		style=filled];	"def:allowable-perm-atoms"	[color=blue,		label="allowable-perm-atoms",		shape=box];	"def:structural-perm-atoms" -> "def:allowable-perm-atoms"	[style=dashed];	"def:structural-perm"	[color=green,		fillcolor="#b0eca3",		label="structural-perm",		shape=box,		style=filled];	"def:structural-perm-atoms" -> "def:structural-perm"	[style=dashed];	"def:strong-support" -> "cor:count-strong-supports"	[style=dashed];	"lem:strengthen-support"	[label="strengthen-support",		shape=ellipse];	"def:strong-support" -> "lem:strengthen-support"	[style=dashed];	"def:support-spec-realisation"	[label="support-spec-realisation",		shape=box];	"def:strong-support" -> "def:support-spec-realisation"	[style=dashed];	"def:coding-function-spec"	[label="coding-function-spec",		shape=box];	"def:coding-function-spec-realisation"	[label="coding-function-spec-realisation",		shape=box];	"def:coding-function-spec" -> "def:coding-function-spec-realisation"	[style=dashed];	"lem:count-coding-function-specs"	[label="count-coding-function-specs",		shape=ellipse];	"def:coding-function-spec" -> "lem:count-coding-function-specs"	[style=dashed];	"cor:count-coding-functions"	[label="count-coding-functions",		shape=ellipse];	"cor:count-tangles"	[color=blue,		label="count-tangles",		shape=ellipse];	"cor:count-coding-functions" -> "cor:count-tangles";	"def:support"	[color=green,		fillcolor="#b0eca3",		label=support,		shape=box,		style=filled];	"def:support-of"	[color=green,		fillcolor="#b0eca3",		label="support-of",		shape=box,		style=filled];	"def:support" -> "def:support-of"	[style=dashed];	"def:allowable-partial-perm-order"	[color=green,		fillcolor="#b0eca3",		label="allowable-partial-perm-order",		shape=box,		style=filled];	"lem:maximal-allowable-partial-perm-total"	[color=green,		fillcolor="#a3d6ff",		label="maximal-allowable-partial-perm-total",		shape=ellipse,		style=filled];	"def:allowable-partial-perm-order" -> "lem:maximal-allowable-partial-perm-total"	[style=dashed];	"prop:allowable-partial-perm-chain-union"	[color=green,		label="allowable-partial-perm-chain-union",		shape=ellipse];	"def:allowable-partial-perm-order" -> "prop:allowable-partial-perm-chain-union"	[style=dashed];	"def:tangle-completed"	[label="tangle-completed",		shape=box];	"def:code-parity"	[color=green,		fillcolor="#b0eca3",		label="code-parity",		shape=box,		style=filled];	"def:code-parity" -> "lem:code-parity-properties"	[style=dashed];	"def:allowable-perm"	[color=green,		fillcolor="#b0eca3",		label="allowable-perm",		shape=box,		style=filled];	"lem:coherence-unpacked"	[color=green,		fillcolor="#9cec8b",		label="coherence-unpacked",		shape=ellipse,		style=filled];	"def:allowable-perm" -> "lem:coherence-unpacked"	[style=dashed];	"lem:supportedness-equiv"	[color=blue,		fillcolor="#a3d6ff",		label="supportedness-equiv",		shape=ellipse,		style=filled];	"def:allowable-perm" -> "lem:supportedness-equiv"	[style=dashed];	"lem:coding-function-has-spec" -> "cor:count-coding-functions";	"def:support-condition-action"	[color=green,		fillcolor="#b0eca3",		label="support-condition-action",		shape=box,		style=filled];	"def:support-condition-action" -> "def:support-of"	[style=dashed];	"def:typed-singleton"	[color=green,		fillcolor="#a3d6ff",		label="typed-singleton",		shape=ellipse,		style=filled];	"def:tangle-data-propagates"	[label="tangle-data-propagates",		shape=box];	"def:typed-singleton" -> "def:tangle-data-propagates"	[style=dashed];	"lem:tangle-action"	[color=green,		fillcolor="#a3d6ff",		label="tangle-action",		shape=ellipse,		style=filled];	"lem:tangle-action" -> "def:tangle-data-propagates"	[style=dashed];	"def:near-litter" -> "def:structural-perm-atoms"	[style=dashed];	"def:local-cardinal"	[color=green,		fillcolor="#b0eca3",		label="local-cardinal",		shape=box,		style=filled];	"def:near-litter" -> "def:local-cardinal"	[style=dashed];	"lem:count-near-litters"	[color=green,		fillcolor="#9cec8b",		label="count-near-litters",		shape=ellipse,		style=filled];	"def:near-litter" -> "lem:count-near-litters"	[style=dashed];	"def:support-condition"	[color=green,		fillcolor="#b0eca3",		label="support-condition",		shape=box,		style=filled];	"def:near-litter" -> "def:support-condition"	[style=dashed];	"def:allowable-partial-perm"	[color=green,		fillcolor="#b0eca3",		label="allowable-partial-perm",		shape=box,		style=filled];	"def:condition-functoriality" -> "def:allowable-partial-perm"	[style=dashed];	"prop:conditions-from-perm-restriction"	[color=green,		fillcolor="#9cec8b",		label="conditions-from-perm-restriction",		shape=ellipse,		style=filled];	"def:condition-functoriality" -> "prop:conditions-from-perm-restriction"	[style=dashed];	"prop:total-1-1-restriction"	[color=blue,		label="total-1-1-restriction",		shape=ellipse];	"def:condition-functoriality" -> "prop:total-1-1-restriction"	[style=dashed];	"def:condition-total-1-1"	[color=green,		fillcolor="#b0eca3",		label="condition-total-1-1",		shape=box,		style=filled];	"def:condition-total-1-1" -> "def:allowable-partial-perm"	[style=dashed];	"prop:total-1-1-gives-perm"	[color=green,		label="total-1-1-gives-perm",		shape=ellipse];	"def:condition-total-1-1" -> "prop:total-1-1-gives-perm"	[style=dashed];	"def:condition-total-1-1" -> "prop:total-1-1-restriction"	[style=dashed];	"def:allowable-partial-perm" -> "def:allowable-partial-perm-order"	[style=dashed];	"prop:restrict-allowable-partial-perm"	[color=green,		label="restrict-allowable-partial-perm",		shape=ellipse];	"def:allowable-partial-perm" -> "prop:restrict-allowable-partial-perm"	[style=dashed];	"def:foa-property"	[color=green,		fillcolor="#b0eca3",		label="foa-property",		shape=box,		style=filled];	"def:allowable-partial-perm" -> "def:foa-property"	[style=dashed];	"def:code-equiv"	[color=green,		fillcolor="#b0eca3",		label="code-equiv",		shape=box,		style=filled];	"lem:code-parity-properties" -> "def:code-equiv"	[style=dashed];	"prop:restrict-allowable-partial-perm" -> "lem:maximal-allowable-partial-perm-total";	"prop:total-allowable-partial-perm-actual"	[color=green,		fillcolor="#a3d6ff",		label="total-allowable-partial-perm-actual",		shape=ellipse,		style=filled];	"prop:restrict-allowable-partial-perm" -> "prop:total-allowable-partial-perm-actual";	"def:main-recursion"	[label="main-recursion",		shape=box];	"def:main-recursion" -> "def:tangle-completed"	[style=dashed];	"thm:foa-propagates"	[color=green,		fillcolor="#9cec8b",		label="foa-propagates",		shape=ellipse,		style=filled];	"lem:maximal-allowable-partial-perm-total" -> "thm:foa-propagates";	"lem:small-subsets-closure"	[color=green,		label="small-subsets-closure",		shape=ellipse];	"prop:conditions-from-perm-restriction" -> "prop:restrict-allowable-partial-perm";	"lem:f-map-properties"	[color=green,		fillcolor="#9cec8b",		label="f-map-properties",		shape=ellipse,		style=filled];	"lem:a-map-properties"	[color=green,		fillcolor="#9cec8b",		label="a-map-properties",		shape=ellipse,		style=filled];	"lem:f-map-properties" -> "lem:a-map-properties";	"lem:f-map-properties" -> "prop:constrains-well-founded"	[style=dashed];	"def:structural-perm-derivative"	[color=green,		fillcolor="#b0eca3",		label="structural-perm-derivative",		shape=box,		style=filled];	"def:structural-perm" -> "def:structural-perm-derivative"	[style=dashed];	"def:semi-tangle-action"	[color=blue,		label="semi-tangle-action",		shape=box];	"def:tangle"	[color=green,		fillcolor="#b0eca3",		label=tangle,		shape=box,		style=filled];	"def:semi-tangle-action" -> "def:tangle"	[style=dashed];	"def:condition-dom-rge" -> "def:condition-total-1-1"	[style=dashed];	"lem:a-map-properties" -> "lem:a-map-wf";	"def:path"	[color=green,		fillcolor="#b0eca3",		label=path,		shape=box,		style=filled];	"def:type-index" -> "def:path"	[style=dashed];	"def:flexible-condition"	[color=green,		fillcolor="#b0eca3",		label="flexible-condition",		shape=box,		style=filled];	"def:flexible-condition" -> "def:allowable-partial-perm"	[style=dashed];	"def:coding-function"	[color=blue,		label="coding-function",		shape=box];	"def:coding-function" -> "def:coding-function-spec"	[style=dashed];	"def:coding-function" -> "cor:count-coding-functions"	[style=dashed];	"def:code-equiv" -> "def:allowable-perm"	[style=dashed];	"lem:code-equiv-properties"	[color=green,		fillcolor="#9cec8b",		label="code-equiv-properties",		shape=ellipse,		style=filled];	"def:code-equiv" -> "lem:code-equiv-properties"	[style=dashed];	"def:semiallowable-perm"	[color=green,		fillcolor="#b0eca3",		label="semiallowable-perm",		shape=box,		style=filled];	"def:code-action"	[color=green,		fillcolor="#b0eca3",		label="code-action",		shape=box,		style=filled];	"def:semiallowable-perm" -> "def:code-action"	[style=dashed];	"def:tangle" -> "def:typed-singleton"	[style=dashed];	"def:tangle" -> "lem:tangle-action"	[style=dashed];	"def:tangle" -> "lem:small-subsets-closure"	[style=dashed];	"def:typed-near-litter"	[color=green,		label="typed-near-litter",		shape=ellipse];	"def:tangle" -> "def:typed-near-litter"	[style=dashed];	"lem:count-supports"	[color=green,		fillcolor="#9cec8b",		label="count-supports",		shape=ellipse,		style=filled];	"lem:count-supports" -> "cor:count-tangles";	"lem:parity-action"	[color=green,		fillcolor="#9cec8b",		label="parity-action",		shape=ellipse,		style=filled];	"lem:parity-action" -> "def:semi-tangle-action"	[style=dashed];	"def:f-map"	[color=green,		fillcolor="#b0eca3",		label="f-map",		shape=box,		style=filled];	"def:f-map" -> "lem:f-map-properties"	[style=dashed];	"def:a-map"	[color=green,		fillcolor="#b0eca3",		label="a-map",		shape=box,		style=filled];	"def:f-map" -> "def:a-map"	[style=dashed];	"def:pretangle"	[color=green,		fillcolor="#b0eca3",		label=pretangle,		shape=box,		style=filled];	"def:tangle-data"	[color=green,		fillcolor="#b0eca3",		label="tangle-data",		shape=box,		style=filled];	"def:pretangle" -> "def:tangle-data"	[style=dashed];	"def:support-of" -> "def:tangle"	[style=dashed];	"def:support-of" -> "lem:count-supports"	[style=dashed];	"def:support-of" -> "lem:supportedness-equiv"	[style=dashed];	"def:support-of" -> "def:tangle-data"	[style=dashed];	"def:restrict-foa-context"	[color=green,		fillcolor="#b0eca3",		label="restrict-foa-context",		shape=box,		style=filled];	"def:restrict-foa-context" -> "prop:restrict-allowable-partial-perm"	[style=dashed];	"def:typed-near-litter" -> "def:tangle-data-propagates"	[style=dashed];	"def:atoms-and-litters" -> "def:near-litter"	[style=dashed];	"def:atoms-and-litters" -> "def:pretangle"	[style=dashed];	"def:atoms-and-litters" -> "def:support-condition"	[style=dashed];	"def:code-action" -> "def:allowable-perm"	[style=dashed];	"def:synthesise-foa-context"	[label="synthesise-foa-context",		shape=box];	"def:tangle-data-propagates" -> "def:synthesise-foa-context"	[style=dashed];	"def:synthesise-foa-context" -> "thm:foa-propagates"	[style=dashed];	"def:synthesise-foa-context" -> "prop:total-allowable-partial-perm-actual"	[style=dashed];	"def:struct-perm-extends" -> "def:foa-property"	[style=dashed];	"prop:allowable-partial-perm-action"	[color=green,		fillcolor="#a3d6ff",		label="allowable-partial-perm-action",		shape=ellipse,		style=filled];	"def:foa-property" -> "prop:allowable-partial-perm-action"	[style=dashed];	"lem:position-functions-propagate"	[color=blue,		label="position-functions-propagate",		shape=ellipse];	"def:foa-property" -> "lem:position-functions-propagate"	[style=dashed];	"def:foa-property" -> "thm:foa-propagates"	[style=dashed];	"def:foa-property" -> "cor:count-tangles"	[style=dashed];	"def:foa-property" -> "prop:total-allowable-partial-perm-actual"	[style=dashed];	"prop:allowable-partial-perm-action" -> "lem:maximal-allowable-partial-perm-total";	"def:local-cardinal" -> "def:a-map"	[style=dashed];	"def:embedding-into-pretangles"	[color=blue,		label="embedding-into-pretangles",		shape=box];	"def:embedding-into-pretangles" -> "def:tangle-data-propagates"	[style=dashed];	"prop:constrains-well-founded" -> "lem:maximal-allowable-partial-perm-total";	"prop:constrains-well-founded" -> "lem:strengthen-support";	"def:semi-tangle"	[color=green,		fillcolor="#b0eca3",		label="semi-tangle",		shape=box,		style=filled];	"def:semi-tangle" -> "def:ttt-membership"	[style=dashed];	"def:semi-tangle" -> "def:semi-tangle-action"	[style=dashed];	"def:semi-tangle" -> "def:embedding-into-pretangles"	[style=dashed];	"def:foa-context"	[color=green,		fillcolor="#b0eca3",		label="foa-context",		shape=box,		style=filled];	"def:foa-context" -> "def:constrains"	[style=dashed];	"def:foa-context" -> "def:strong-support"	[style=dashed];	"def:foa-context" -> "def:flexible-condition"	[style=dashed];	"def:foa-context" -> "def:coding-function"	[style=dashed];	"def:foa-context" -> "def:restrict-foa-context"	[style=dashed];	"def:foa-context" -> "def:synthesise-foa-context"	[style=dashed];	"def:support-spec"	[color=blue,		label="support-spec",		shape=box];	"def:foa-context" -> "def:support-spec"	[style=dashed];	"lem:strengthen-support" -> "cor:count-tangles";	"def:a-map" -> "lem:a-map-wf"	[style=dashed];	"def:a-map" -> "def:code-parity"	[style=dashed];	"def:a-map" -> "lem:a-map-properties"	[style=dashed];	"lem:position-functions-propagate" -> "def:main-recursion"	[style=dashed];	"prop:total-1-1-restriction" -> "prop:restrict-allowable-partial-perm";	"thm:foa-propagates" -> "def:main-recursion"	[style=dashed];	"def:code"	[color=green,		fillcolor="#b0eca3",		label=code,		shape=box,		style=filled];	"def:code" -> "def:code-action"	[style=dashed];	"def:code" -> "def:a-map"	[style=dashed];	"cor:count-tangles" -> "lem:position-functions-propagate";	"def:support-spec" -> "def:coding-function-spec"	[style=dashed];	"def:support-spec" -> "def:support-spec-realisation"	[style=dashed];	"lem:count-support-specs"	[label="count-support-specs",		shape=ellipse];	"def:support-spec" -> "lem:count-support-specs"	[style=dashed];	"def:support-spec-realisation" -> "lem:strong-support-has-spec"	[style=dashed];	"def:support-spec-realisation" -> "def:coding-function-spec-realisation"	[style=dashed];	"lem:support-spec-realisation-unique"	[label="support-spec-realisation-unique",		shape=ellipse];	"def:support-spec-realisation" -> "lem:support-spec-realisation-unique"	[style=dashed];	"lem:count-near-litters" -> "lem:count-supports";	"lem:code-equiv-properties" -> "lem:parity-action";	"lem:code-equiv-properties" -> "def:semi-tangle"	[style=dashed];	"prop:total-allowable-partial-perm-actual" -> "thm:foa-propagates";	"def:support-condition" -> "def:binary-condition"	[style=dashed];	"def:support-condition" -> "def:support"	[style=dashed];	"def:support-condition" -> "def:support-condition-action"	[style=dashed];	"def:coding-function-spec-realisation" -> "lem:coding-function-has-spec"	[style=dashed];	"lem:coherence-unpacked" -> "lem:parity-action";	"lem:coherence-unpacked" -> "prop:total-allowable-partial-perm-actual";	"lem:supportedness-equiv" -> "def:typed-near-litter";	"lem:count-support-specs" -> "cor:count-strong-supports";	"def:structural-perm-derivative" -> "def:support-condition-action"	[style=dashed];	"lem:count-coding-function-specs" -> "cor:count-coding-functions";	"def:tangle-data" -> "def:semiallowable-perm"	[style=dashed];	"def:tangle-data" -> "def:f-map"	[style=dashed];	"def:tangle-data" -> "def:embedding-into-pretangles"	[style=dashed];	"def:tangle-data" -> "def:foa-context"	[style=dashed];	"def:tangle-data" -> "def:code"	[style=dashed];	"def:struct-perm-graph" -> "prop:total-1-1-gives-perm"	[style=dashed];	"def:struct-perm-graph" -> "prop:conditions-from-perm-restriction"	[style=dashed];	"def:struct-perm-graph" -> "def:foa-property"	[style=dashed];	"prop:allowable-partial-perm-chain-union" -> "thm:foa-propagates";}')
    .on("end", interactive);

clickNode = function() {
  $("#statements div").hide()
  var node_id = $('text', this).text();
    console.log(node_id);
  console.log('#'+node_id.replace(':', '\\:'));
  $('.thm').hide();
  $('#'+node_id.replace(':', '\\:')).show().children().show();
}
function interactive() {
    $("span#legend_title").on("click", function () {
           $(this).siblings('dl').toggle();
        })

    d3.selectAll('.node')
        .attr('pointer-events', 'fill')
        .on('click', function () {
           var title = d3.select(this).selectAll('title').text().trim();
           $('#statements > div').hide()
           $('.thm').hide();
           $('#'+title.replace(':', '\\:')+'_modal').show().children().show().children().show();
           $('#statements').show()
        });

    d3.selectAll('.dep-closebtn').on('click', function() {
        var modal =
            d3.select(this).node().parentNode.parentNode.parentNode ;
        d3.select(modal).style('display', 'none');
    });
}

</script>

</body>
</html>
